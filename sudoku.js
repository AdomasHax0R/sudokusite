// sudoku.js - tiny, dependency free sudoku ui js program
//works with pages generated by sudoku_module.c and also with the static sudoku.html template

//features
//click to select an empty cell
//type 1..9 to fill, backspace/delete to clear
//optional validation if the page provides data-solution="81 digits"
//start/pause/reset timer buttons
//mistakes counter (max 3) when solution is available

(function () {
  "use strict";

  function pad2(n) {
    return String(n).padStart(2, "0");
  }

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return `${pad2(m)}:${pad2(s)}`;
  }

  function parseSolutionString(s) {
    //expectinam 81 chars: '1'..'9'. whitespace irgi okay
    if (!s) return null;
    const cleaned = String(s).replace(/\s+/g, "");
    if (cleaned.length !== 81) return null;
    for (let i = 0; i < cleaned.length; i++) {
      const ch = cleaned[i];
      if (ch < "1" || ch > "9") return null;
    }
    return cleaned;
  }

  document.addEventListener("DOMContentLoaded", function () {
    const container = document.querySelector(".game .container");
    if (!container) return;

    const cells = Array.from(container.querySelectorAll(".cell"));
    if (cells.length !== 81) return;

    const solution = parseSolutionString(container.getAttribute("data-solution"));
    const timeEl = document.querySelector(".score .time");
    const pointsEl = document.querySelector(".score .points");
    const mistakesEl = document.querySelector(".score .mistakes");

    const btns = Array.from(document.querySelectorAll(".difficulty .buttons .b"));
    const startBtn =
      btns.find((b) => b.getAttribute("data-action") === "start") ||
      btns.find((b) => (b.textContent || "").trim().toLowerCase() === "start");
    const pauseBtn =
      btns.find((b) => b.getAttribute("data-action") === "pause") ||
      btns.find((b) => (b.textContent || "").trim().toLowerCase() === "pause") ||
      btns.find((b) => (b.textContent || "").trim().toLowerCase() === "resume");
    const resetBtn =
      btns.find((b) => b.getAttribute("data-action") === "reset") ||
      btns.find((b) => (b.textContent || "").trim().toLowerCase() === "reset");

    let selectedIdx = -1;
    let started = false;
    let timerId = null;
    let seconds = 0;
    let mistakes = 0;
    let maxMistakes = 3;
    let points = 0;
    let pointsPerCorrect = 10;
    let pointsPenaltyWrong = 0;
    let currentDifficulty = "medium";

    function setTimeText() {
      if (timeEl) timeEl.textContent = `Time: ${formatTime(seconds)}`;
    }


    function setPointsText() {
      if (pointsEl) pointsEl.textContent = `Score: ${points}`;
    }

    function setMistakesText() {
      if (mistakesEl) mistakesEl.textContent = `Mistakes: ${mistakes}/${maxMistakes}`;
    }

    function clearSelection() {

      if (selectedIdx >= 0 && selectedIdx < cells.length) {
        cells[selectedIdx].classList.remove("selected");
      }
      selectedIdx = -1;
    }

    function selectCell(idx) {
      if (idx < 0 || idx >= cells.length) return;
      if (!cells[idx].classList.contains("editable")) return;

      clearSelection();
      selectedIdx = idx;
      cells[selectedIdx].classList.add("selected");
      cells[selectedIdx].focus({ preventScroll: true });
    }

    function idxToRC(idx) {
      return { r: Math.floor(idx / 9), c: idx % 9 };
    }

    function moveSelection(dr, dc) {
      if (selectedIdx < 0) return;
      const { r, c } = idxToRC(selectedIdx);
      let nr = r + dr;
      let nc = c + dc;
      if (nr < 0) nr = 0;
      if (nr > 8) nr = 8;
      if (nc < 0) nc = 0;
      if (nc > 8) nc = 8;
      selectCell(nr * 9 + nc);
    }

    function lockIfLost() {
      if (mistakes < maxMistakes) return false;
      // lock input
      cells.forEach((cell) => {
        if (cell.classList.contains("editable")) cell.classList.add("locked");
      });
      clearSelection();
      return true;
    }

    function isComplete() {
      for (const cell of cells) {
        if (cell.classList.contains("editable") && (cell.textContent || "").trim() === "") {
          return false;
        }
      }
      return true;
    }

    function checkWinIfPossible() {
      if (!solution) return;
      if (!isComplete()) return;
      for (let i = 0; i < 81; i++) {
        const cell = cells[i];
        const v = (cell.textContent || "").trim();
        const expected = solution[i];
        if (v !== expected) return;
      }
      //simple win: stop timer
      if (timerId) window.clearInterval(timerId);
      timerId = null;
      started = false;
      container.classList.add("won");
    }

    function setCellValue(idx, valueChar) {
      if (idx < 0 || idx >= 81) return;
      const cell = cells[idx];
      if (!cell.classList.contains("editable")) return;
      if (cell.classList.contains("locked")) return;

      const value = valueChar ? String(valueChar).trim() : "";
      cell.classList.remove("wrong", "correct");

      if (value === "") {
        cell.textContent = "";
        return;
      }

      cell.textContent = value;

      if (solution) {
        const expected = solution[idx];
        if (value !== expected) {
          mistakes += 1;
          setMistakesText();
          cell.classList.add("wrong");
          if (pointsPenaltyWrong) {
            points = Math.max(0, points - pointsPenaltyWrong);
            setPointsText();
          }
          if (lockIfLost()) return;
        } else {
          points += pointsPerCorrect;
          setPointsText();
          cell.classList.add("correct");
        }
        checkWinIfPossible();
      }
    }



    //mark givens/editables; make editables focusable for keyboard
    cells.forEach((cell) => {
      const isGiven = cell.classList.contains("given") && (cell.textContent || "").trim() !== "";
      if (isGiven) {
        cell.classList.add("given");
        cell.setAttribute("tabindex", "-1");
      } else {
        cell.classList.add("editable");
        cell.setAttribute("tabindex", "0");
        if ((cell.textContent || "").trim() === "") cell.textContent = "";
      }
    });

    //initialize scoreboard if present
    setTimeText();
    setPointsText();
    setMistakesText();

    container.addEventListener("click", function (e) {
      const target = e.target;
      if (!(target instanceof HTMLElement)) return;
      if (!target.classList.contains("cell")) return;
      const idx = cells.indexOf(target);
      if (idx === -1) return;
      selectCell(idx);
    });

    document.addEventListener("keydown", function (e) {
      if (selectedIdx < 0) return;
      const cell = cells[selectedIdx];
      if (!cell.classList.contains("editable") || cell.classList.contains("locked")) return;

      const k = e.key;
      if (k === "ArrowUp") {
        e.preventDefault();
        moveSelection(-1, 0);
        return;
      }
      if (k === "ArrowDown") {
        e.preventDefault();
        moveSelection(1, 0);
        return;
      }
      if (k === "ArrowLeft") {
        e.preventDefault();
        moveSelection(0, -1);
        return;
      }
      if (k === "ArrowRight") {
        e.preventDefault();
        moveSelection(0, 1);
        return;
      }
      if (k === "Backspace" || k === "Delete" || k === "0") {
        e.preventDefault();
        setCellValue(selectedIdx, "");
        return;
      }
      if (k.length === 1 && k >= "1" && k <= "9") {
        e.preventDefault();
        setCellValue(selectedIdx, k);
      }
    });

    function startTimer() {
      if (timerId) return; // already running
      started = true;
      timerId = window.setInterval(function () {
        seconds += 1;
        setTimeText();
      }, 1000);
      if (pauseBtn) pauseBtn.textContent = "Pause";
    }

    function pauseTimer() {
      started = false;
      if (timerId) window.clearInterval(timerId);
      timerId = null;
      if (pauseBtn) pauseBtn.textContent = "Resume";
    }

    function resetGame() {
      pauseTimer();
      seconds = 0;
      mistakes = 0;
      points = 0;
      container.classList.remove("won");
      cells.forEach((cell) => {
        if (cell.classList.contains("editable")) {
          cell.textContent = "";
          cell.classList.remove("wrong", "correct", "locked", "selected");
        }
      });
      clearSelection();
      setTimeText();
      setMistakesText();
      setPointsText();
    }

    if (startBtn) startBtn.addEventListener("click", startTimer);
    if (pauseBtn)
      pauseBtn.addEventListener("click", function () {
        //toggle pause/resume
        if (timerId) pauseTimer();
        else startTimer();
      });
    if (resetBtn) resetBtn.addEventListener("click", resetGame);

    function applyDifficulty(name) {
      if (name === currentDifficulty) return;
      currentDifficulty = name;
      if (name === "easy") {
        maxMistakes = 5;
        pointsPerCorrect = 5;
        pointsPenaltyWrong = 0;
      } else if (name === "hard") {
        maxMistakes = 2;
        pointsPerCorrect = 15;
        pointsPenaltyWrong = 0;
      } else {
        // medium (default)
        maxMistakes = 3;
        pointsPerCorrect = 10;
        pointsPenaltyWrong = 0;
      }
      //reset stats
      resetGame();
      setMistakesText();
      setPointsText();
    }

    function isSiteDifficultyPage() {
      const p = (window.location && window.location.pathname) ? window.location.pathname : "";
      const lower = String(p).toLowerCase();
      return (
        lower.endsWith("/sudoku_easy.html") ||
        lower.endsWith("/sudoku_medium.html") ||
        lower.endsWith("/sudoku_hard.html") ||
        lower.endsWith("\\sudoku_easy.html") ||
        lower.endsWith("\\sudoku_medium.html") ||
        lower.endsWith("\\sudoku_hard.html")
      );
    }

    //diff handling:
    //on the generated site pages (sudoku_easy/medium/hard.html), links navigate between pages.

    //on standalone pages (e.g. generated_sudoku.html), we prevent navigation so it doesn't 404,
    //and instead apply local difficulty parameters (mistake limit / scoring)
    const diffLis = Array.from(document.querySelectorAll(".difficulty li"));
    diffLis.forEach((li) => {
      li.addEventListener("click", function (e) {
        const label = (li.textContent || "").trim().toLowerCase();
        const link = li.querySelector("a[href]");
        const hasLink = !!link;

        diffLis.forEach((x) => x.classList.remove("active"));
        li.classList.add("active");

        if (label !== "easy" && label !== "medium" && label !== "hard") return;


        if (hasLink && !isSiteDifficultyPage()) {
          //standalone mode: don't navigate to missing pages
          e.preventDefault();
          applyDifficulty(label);
          return;
        }

        if (!hasLink) {
          //older pages without links: local-only difficulty parameters
          applyDifficulty(label);
        }
      });
    });

    //if the page already has an active difficulty, apply it once
    const active = diffLis.find((li) => li.classList.contains("active"));
    if (active) {
      const label = (active.textContent || "").trim().toLowerCase();
      if (label === "easy" || label === "medium" || label === "hard") {
        applyDifficulty(label);
      }
    }
  });
})();

